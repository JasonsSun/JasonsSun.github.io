<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java笔记之取整函数总结]]></title>
    <url>%2F2019%2F07%2F12%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[java的四种取整方法11.public static double ceil(double a)//向上取整 测试用例： System.out.println(Math.ceil(1.01));System.out.println(Math.ceil(-1.01));System.out.println(Math.ceil(1.5));System.out.println(Math.ceil(-1.5)); 结果如下： 2.0-1.02.0-1.0 12.public static double floor(double a)//向下取整 Math.floor(-1.1): -2.0Math.floor(-1.5): -2.0Math.floor(-1.6): -2.0Math.floor(0.1): 0.0Math.floor(0.5): 0.0Math.floor(0.6): 0.0Math.floor(1.1): 1.0Math.floor(11.5): 11.0Math.floor(15.7): 15.0 Math.floor(-0.5): -0.0 测试用例： 123456789101112131415161718舍掉小数取整:Math.floor(2)=2舍掉小数取整:Math.floor(2.1)=2舍掉小数取整:Math.floor(2.5)=2舍掉小数取整:Math.floor(2.9)=2负数舍掉小数取整:Math.floor(-2)=-2负数舍掉小数取整:Math.floor(-2.1)=-3负数舍掉小数取整:Math.floor(-2.5)=-3负数舍掉小数取整:Math.floor(-2.9)=-3 见小数取整:Math.ceil(2)=2见小数取整:Math.ceil(2.1)=3见小数取整:Math.ceil(2.5)=3见小数取整:Math.ceil(2.9)=3 负数见小数取整:Math.ceil(-2)=-2负数见小数取整:Math.ceil(-2.1)=-2负数见小数取整:Math.ceil(-2.5)=-2负数见小数取整:Math.ceil(-2.9)=-2 13.RoundingMode模式 例子： 1234567891011RoundingMode.CEILING：取右边最近的整数RoundingMode.DOWN：去掉小数部分取整，也就是正数取左边，负数取右边，相当于向原点靠近的方向取整RoundingMode.FLOOR：取左边最近的正数RoundingMode.HALF_DOWN:五舍六入，负数先取绝对值再五舍六入再负数RoundingMode.HALF_UP:四舍五入，负数原理同上RoundingMode.HALF_EVEN:这个比较绕，整数位若是奇数则四舍五入，若是偶数则五舍六入 同理：类似于四舍五入 1Math.round(x) = Math.floor(x + 0.5) Math.round(-1.1): -1Math.round(-1.5): -1Math.round(-1.6): -2Math.round(0.1): 0Math.round(0.5): 1Math.round(0.6): 1Math.round(1.1): 1Math.round(1.5): 2Math.round(1.6): 2 14.Math.rint 函数返回最接近参数的整数，如果有2个数同样接近，则会返回偶数的那个。 测试用例： Math.rint(-1.1): -1.0Math.rint(-1.5): -2.0Math.rint(-1.6): -2.0Math.rint(0.1): 0.0Math.rint(0.5): 0.0Math.rint(0.6): 1.0Math.rint(1.1): 1.0Math.rint(1.5): 2.0Math.rint(1.6): 2.0 使用举例结合cron表达式实现根据时间差获取分钟数取整 12345678910Double count=0d; if(cron!=null&amp;&amp;maxCount!=null) &#123; CronSequenceGenerator cronSequenceGenerator = new CronSequenceGenerator(cron); Date currentTime = new Date(); Date nextTimePoint = cronSequenceGenerator.next(currentTime); // currentTime为计算下次时间点的开始时间 Date nextNextTimePoint = cronSequenceGenerator.next(nextTimePoint); int minute = (int) ((nextNextTimePoint.getTime() - nextTimePoint.getTime())); // 计算秒 count = (Double.parseDouble(maxCount.trim()) * 60 * 60 * 1000) / minute; &#125; return (int)Math.ceil(count.doubleValue()); cron表达式详解 Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： （1） Seconds Minutes Hours DayofMonth Month DayofWeek Year （2）Seconds Minutes Hours DayofMonth Month DayofWeek ** 一、结构** corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份 ** 二、各字段的含义** | 字段 | 允许值 | 允许的特殊字符 || 秒（Seconds） | 059的整数 | , - * / 四个字符 || 分（_Minutes_） | 059的整数 | , - * / 四个字符 || 小时（_Hours_） | 023的整数 | , - * / 四个字符 || 日期（_DayofMonth_） | 131的整数（但是你需要考虑你月的天数） | ,- * ? / L W C 八个字符 || 月份（_Month_） | 112的整数或者 JAN-DEC | , - * / 四个字符 || 星期（_DayofWeek_） | 17的整数或者 SUN-SAT （1=SUN） | , - * ? / L C # 八个字符 || 年(可选，留空)（_Year_） | 1970~2099 | , - * / 四个字符 | 注意事项： 每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： （1）：表示匹配该域的任意值。假如在Minutes域使用, 即表示每分钟都会触发事件。 （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。 （3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 （4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. （5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 （6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 （7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 （8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 （9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 三、常用表达式例子 （1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 （2）*0 15 10 ? * MON-FRI * 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）*0 15 10 ? * * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）*0 15 10 * * ? * * 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）*0 0-5 14 * * ? * 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）*0 15 10 ? * MON-FRI * 周一至周五的上午10:15触发 （18）*0 15 10 15 * ? * 每月15日上午10:15触发 （19）*0 15 10 L * ? * 每月最后一日的上午10:15触发 （20）*0 15 10 ? * 6L * 每月的最后一个星期五上午10:15触发 （21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 （22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 ** 注：** （1）有些子表达式能包含一些范围或列表 例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT” “*”字符代表所有可能的值 因此，“”在子表达式（月）里表示每个月的含义，“”在子表达式（天（星期））表示星期的每一天 “/”字符用来指定数值的增量 例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样 “？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值 当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？” “L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写 但是它在两个子表达式里的含义是不同的。 在天（月）子表达式中，“L”表示一个月的最后一天 在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT 如果在“L”前有具体的内容，它就具有其他的含义了 例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之MySQL caching_sha2_password 和 mysql_native_password]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMySQL-caching-sha2-password-%E5%92%8C-mysql-native-password%2F</url>
    <content type="text"><![CDATA[1.问题重现Client does not support authentication protocol requested by server; consider upgrading MySQL client 2.说明123为了提供更安全的密码加密，MySQL8.0的首选默认认证插件是caching_sha2_password，而不是mysql_native_password 3.解决办法解决方式或者注意事项： 1.对于MySQL 8.0的升级，身份验证插件现有帐户保持不变，包括’root’@’localhost’管理帐户的插件。2.对于新的MySQL 8.0安装，在初始化数据目录时，将 ‘root’@’localhost’创建帐户，并且该帐户caching_sha2_password默认使用。3.对于新的MySQL 8.0安装，还想使用之前的密码认证方式请使用1ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; 4.安装的时候两个密码可选加密方式 4.查询自己的数据库和加密方式]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之'hibernate.dialect' not set错误]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B-hibernate-dialect-not-set%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[数据库问题重现Caused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when ‘hibernate.dialect’ not set 解决方式Hibernate SQL方言没有设置导致的，在properties文件中加入： 1spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect Hibernate SQL方言整理如下: | 数据库 | 方言 || ——- | :—— | ——: || DB2| org.hibernate.dialect.DB2Dialect || DB2 AS/400 | org.hibernate.dialect.DB2400Dialect || DB2 OS390 | org.hibernate.dialect.DB2390Dialect| PostgreSQL| org.hibernate.dialect.PostgreSQLDialect| MySQL | org.hibernate.dialect.MySQLDialect| MySQL with InnoDB| org.hibernate.dialect.MySQLInnoDBDialect| MySQL with MyISAM | org.hibernate.dialect.MySQLMyISAMDialect| Oracle (any version) | org.hibernate.dialect.OracleDialect| Oracle 9i/10g | org.hibernate.dialect.Oracle9Dialect| Sybase | org.hibernate.dialect.SybaseDialect| Sybase Anywhere | org.hibernate.dialect.SybaseAnywhereDialect| Microsoft SQL Server | org.hibernate.dialect.SQLServerDialect| SAP DB| org.hibernate.dialect.SAPDBDialect| Informix| org.hibernate.dialect.InformixDialect| HypersonicSQL| org.hibernate.dialect.HSQLDialect| Ingres | org.hibernate.dialect.IngresDialect| Progress| org.hibernate.dialect.ProgressDialect| Mckoi SQL| org.hibernate.dialect.MckoiDialect| Interbase| org.hibernate.dialect.InterbaseDialect| Pointbase| org.hibernate.dialect.PointbaseDialect| FrontBase | org.hibernate.dialect.FrontbaseDialect| Firebird | org.hibernate.dialect.FirebirdDialect]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之Public Key Retrieval is not allowed错误]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BPublic-Key-Retrieval-is-not-allowed%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[数据库问题重现com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Public Key Retrieval is not allowed 解决方式1.mysql5及之前的版本使用的是旧版驱动”com.mysql.jdbc.Driver”，mysql6以及之后的版本需要更新到新版驱动，对应的Driver是”com.mysql.cj.jdbc.Driver”，但是这个驱动错误的信息是”Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.”，排除这个原因。也就是升级Mysql 2.连接数据库的url中，加上_allowPublicKeyRetrieval=true_参数，经过验证解决该问题。3.修改default_authentication_plugin设置，在my.ini中增加[mysqld]default_authentication_plugin=mysql_native_password，然后mysql命令行执行ALTER USER ‘username’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘password’;最后在url中添加时区参数serverTimezone=Asia/Shanghai。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 安装MySQL8.0 Failed 解决办法]]></title>
    <url>%2F2019%2F07%2F08%2FWindows10-%E5%AE%89%E8%A3%85MySQL8-0-Failed-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MySQL下载路径 图示如下：1.MySQL下载路径 2. 出现status failed的解决办法 升级一个插件，即32位 visual C++ 2013 and visual C++ redistributable package，就是缺少这个才会出现failed，其实在安装的过程中跳出过这个的安装，但它是根据电脑直接匹配位数的也就是我们大多数的64位，所以需要再根据链接下载一个32位的,x86下载地址Visual C++ 2013 and Visual C++ Redistributable Package 下载如图: 附加详细安装步骤 MySQL Community Server 5.7安装详细步骤 2019年最新版本：mysql-installer-community-8.0.13.0的安装详细图解 Over Ending（结束语）####MySQL安装告一段落，其余的相关配置 请自行查看官网，去探索吧，少年! 注:如果还有不了解的，可以在右下方与博主在线沟通]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro登陆异常 did not match the expected credentials.]]></title>
    <url>%2F2019%2F06%2F23%2F%E4%BD%BF%E7%94%A8SpringBoot-Shiro%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E8%A7%81%E7%9A%84%E5%AF%86%E7%A0%81%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[错误如下： 1234567891011121314151617 threw exception [Request processing failed; nested exception is org.apache.shiro.authc.IncorrectCredentialsException: Submitted credentials for token [org.apache.shiro.authc.UsernamePasswordToken - admin, rememberMe=true] did not match the expected credentials.] with root causeorg.apache.shiro.authc.IncorrectCredentialsException: Submitted credentials for token [org.apache.shiro.authc.UsernamePasswordToken - admin, rememberMe=true] did not match the expected credentials.at org.apache.shiro.realm.AuthenticatingRealm.assertCredentialsMatch(AuthenticatingRealm.java:600)at org.apache.shiro.realm.AuthenticatingRealm.getAuthenticationInfo(AuthenticatingRealm.java:578)at org.apache.shiro.authc.pam.ModularRealmAuthenticator.doSingleRealmAuthentication(ModularRealmAuthenticator.java:180)at org.apache.shiro.authc.pam.ModularRealmAuthenticator.doAuthenticate(ModularRealmAuthenticator.java:267)at org.apache.shiro.authc.AbstractAuthenticator.authenticate(AbstractAuthenticator.java:198)at org.apache.shiro.mgt.AuthenticatingSecurityManager.authenticate(AuthenticatingSecurityManager.java:106)at org.apache.shiro.mgt.DefaultSecurityManager.login(DefaultSecurityManager.java:270)at org.apache.shiro.subject.support.DelegatingSubject.login(DelegatingSubject.java:256)at com.sk.main.controller.LoginController.login(LoginController.java:36)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.lang.reflect.Method.invoke(Method.java:606)at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221)at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137) 解决方案： 这是shiro返回的密码校验结果不一样，要么你把shiro校验的令牌规则重写，就是按什么方式去校验。 要么你自己把密码加密好传给shiro。 白话文讲：当你登陆的时候，你会创建一个UsernamePasswordToken对象，或者UsernamePasswordToken的子类对象，并且赋予账号、密码、rememberMe，这里的密码你需要和数据库一直，比如你做了md5加密，那么你先做md5加密然后再创建UsernamePasswordToken对象.然后你在校验完毕后： 1return new SimpleAuthenticationInfo(token,memberSecurity.getLoginPswd(), getName()); 这里的第二个参数为密码，shiro会把第二个参数和你开始传进来的参数按规则对比，如果错误（或者是同一个引用对象）就返回上面的错误。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Shiro安全框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Springboot+Shiro权限安全框架]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%90%AD%E5%BB%BASpringboot-Shiro%E6%9D%83%E9%99%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[1. 内容简介主要讲解如何使用Spring Boot与Shiro进行整合使用，实现强大的用户权限管理，其中涉及如何完成用户认证（即用户登录），用户授权，thymeleaf页面整合shiro权限标签等知识点。2. Spring Boot与Shiro框架简介2.1 Spring Boot框架简介Spring的诞生是 Java 企业版（Java Enterprise Edition，JEE，也称 J2EE）的轻量级代替品。无需开发重量级的 Enterprise JavaBean（EJB），Spring 为企业级Java 开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java 对象（Plain Old Java Object，POJO）实现了 EJB 的功能。 虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。 所有Spring配置都代表了开发时的损耗。 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。除此之外，项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 Spring Boot 让这一切成为了过去。Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，或者采用传统的war部署方式。 Spring Boot 主要目标是： 为所有 Spring 的开发提供一个从根本上更快的入门体验。 开箱即用，但通过自己设置参数，即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等。 绝对没有代码生成，也无需 XML 配置。 2.2 Shiro框架简介Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码学和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。 Apache Shiro 体系结构 1、 Authentication 认证 —- 用户登录2、 Authorization 授权 — 用户具有哪些权限3、 Cryptography 安全数据加密4、 Session Management 会话管理5、 Web Integration web系统集成6、 Interations 集成其它应用，spring、缓存框架 3. Spring Boot快速入门3.1. 建立Maven项目，导入spring boot父工程 修改pom.xml：12345678910111213141516&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 继承Spring Boot的默认父工程 --&gt; &lt;!-- Spring Boot 父工程 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springboot-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 3.2 导入web支持123456789&lt;!-- 导入依赖 --&gt; &lt;dependencies&gt; &lt;!-- 导入web支持：SpringMVC开发支持，Servlet相关的程序 --&gt; &lt;!-- web支持，SpringMVC， Servlet支持等 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.3. 编写测试Controller类12345678910111213141516171819package com.itheima.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class UserController &#123; /** * 测试方法 */ @RequestMapping("/hello") @ResponseBody public String hello()&#123; System.out.println("UserController.hello()"); return "ok"; &#125;&#125; 3.4. 编写SpringBoot启动类1234567891011121314151617package com.itheima;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot启动类 * @author lenovo * */@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 3.5. 导入thymeleaf页面模块 引入thymeleaf依赖 12345&lt;!-- 导入thymeleaf依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 在Controller添加测试方法 12345678910/** * 测试thymeleaf */@RequestMapping("/testThymeleaf")public String testThymeleaf(Model model)&#123; //把数据存入model model.addAttribute("name", "黑马程序员"); //返回test.html return "test";&#125; 建立test.html页面在src/main/resource目录下创建templates目录，然后创建test.html页面 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;测试Thymeleaf的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 th:text="$&#123;name&#125;"&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 在thymeleaf3.0以前对页面标签语法要求比较严格，开始标签必须有对应的结束标签。 如果希望页面语法不严谨，但是也能够运行成功，可以把thymeleaf升级为3.0或以上版本。 升级thymeleaf3.0.2版本： 12345678&lt;!-- 修改参数 --&gt; &lt;properties&gt; &lt;!-- 修改JDK的编译版本为1.8 --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- 修改thymeleaf的版本 --&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.0.4&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 4. Spring Boot与Shiro整合实现用户认证4.1分析Shiro的核心APISubject： 用户主体（把操作交给SecurityManager）SecurityManager：安全管理器（关联Realm）Realm：Shiro连接数据的桥梁 4.2. Spring Boot整合Shiro4.2.1. 导入shiro与spring整合依赖修改pom.xml 123456&lt;!-- shiro与spring整合依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; 4.2.2 自定义Realm类1234567891011121314151617181920212223242526272829303132333435package com.itheima.shiro;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * 自定义Realm * @author lenovo * */public class UserRealm extends AuthorizingRealm&#123; /** * 执行授权逻辑 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println("执行授权逻辑"); return null; &#125; /** * 执行认证逻辑 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken arg0) throws AuthenticationException &#123; System.out.println("执行认证逻辑"); return null; &#125;&#125; 4.2.3 编写Shiro配置类（*）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.shiro;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Shiro的配置类 * @author lenovo * */@Configurationpublic class ShiroConfig &#123; /** * 创建ShiroFilterFactoryBean */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager")DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); return shiroFilterFactoryBean; &#125; /** * 创建DefaultWebSecurityManager */ @Bean(name="securityManager") public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier("userRealm")UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联realm securityManager.setRealm(userRealm); return securityManager; &#125; /** * 创建Realm */ @Bean(name="userRealm") public UserRealm getRealm()&#123; return new UserRealm(); &#125;&#125; 4.3 使用Shiro内置过滤器实现页面拦截123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.itheima.shiro;import java.util.LinkedHashMap;import java.util.Map;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Shiro的配置类 * @author lenovo * */@Configurationpublic class ShiroConfig &#123; /** * 创建ShiroFilterFactoryBean */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager")DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加Shiro内置过滤器 /** * Shiro内置过滤器，可以实现权限相关的拦截器 * 常用的过滤器： * anon: 无需认证（登录）可以访问 * authc: 必须认证才可以访问 * user: 如果使用rememberMe的功能可以直接访问 * perms： 该资源必须得到资源权限才可以访问 * role: 该资源必须得到角色权限才可以访问 */ Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;(); /*filterMap.put("/add", "authc"); filterMap.put("/update", "authc");*/ filterMap.put("/testThymeleaf", "anon"); filterMap.put("/*", "authc"); //修改调整的登录页面 shiroFilterFactoryBean.setLoginUrl("/toLogin"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; &#125; /** * 创建DefaultWebSecurityManager */ @Bean(name="securityManager") public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier("userRealm")UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联realm securityManager.setRealm(userRealm); return securityManager; &#125; /** * 创建Realm */ @Bean(name="userRealm") public UserRealm getRealm()&#123; return new UserRealm(); &#125;&#125; 4.4 实现用户认证（登录）操作4.4.1 设计登录页面123456789101112131415161718192021222324252627282930313233| &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=_"UTF-8"_&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;登录&lt;/h3&gt;&lt;form method=_"post"_ action=_"login"_&gt; 用户名:&lt;input type=_"text"_ name=_"name"_/&gt;&lt;br/&gt; 密码：&lt;input type=_"password"_ name=_"password"_/&gt;&lt;br/&gt; &lt;input type=_"submit"_ value=_"__登录"_/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; | 4.4.2 编写Controller的登录逻辑1234567891011121314151617181920212223242526272829303132333435/** * 登录逻辑处理 */@RequestMapping("/login")public String login(String name,String password,Model model)&#123; /** * 使用Shiro编写认证操作 */ //1.获取Subject Subject subject = SecurityUtils.getSubject(); //2.封装用户数据 UsernamePasswordToken token = new UsernamePasswordToken(name,password); //3.执行登录方法 try &#123; subject.login(token); //登录成功 //跳转到test.html return "redirect:/testThymeleaf"; &#125; catch (UnknownAccountException e) &#123; //e.printStackTrace(); //登录失败:用户名不存在 model.addAttribute("msg", "用户名不存在"); return "login"; &#125;catch (IncorrectCredentialsException e) &#123; //e.printStackTrace(); //登录失败:密码错误 model.addAttribute("msg", "密码错误"); return "login"; &#125;&#125; 4.4.3. 编写Realm的判断逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.itheima.shiro;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * 自定义Realm * @author lenovo * */public class UserRealm extends AuthorizingRealm&#123; /** * 执行授权逻辑 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println("执行授权逻辑"); return null; &#125; /** * 执行认证逻辑 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken arg0) throws AuthenticationException &#123; System.out.println("执行认证逻辑"); //假设数据库的用户名和密码 String name = "eric"; String password = "123456"; //编写shiro判断逻辑，判断用户名和密码 //1.判断用户名 UsernamePasswordToken token = (UsernamePasswordToken)arg0; if(!token.getUsername().equals(name))&#123; //用户名不存在 return null;//shiro底层会抛出UnKnowAccountException &#125; //2.判断密码 return new SimpleAuthenticationInfo("",password,""); &#125;&#125; 4.5 整合MyBatis实现登录4.5.1 导入mybatis相关的依赖1234567891011121314151617&lt;!-- 导入mybatis相关的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot的Mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 4.5.2 配置application.properties位置：src/main/resources目录下 1234567891011spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=rootspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.itheima.domain 4.5.3 编写User实体1234567891011121314151617181920212223242526package com.itheima.domain;public class User &#123; private Integer id; private String name; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 4.5.4. 编写UserMapper接口12345678package com.itheima.mapper;import com.itheima.domain.User;public interface UserMapper &#123; public User findByName(String name);&#125; 4.5.5. 编写UserMapper.xml映射文件123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 该文件存放CRUD的sql语句 --&gt;&lt;mapper namespace="com.itheima.mapper.UserMapper"&gt; &lt;select id="findByName" parameterType="string" resultType="user"&gt; SELECT id, NAME, PASSWORD FROM user where name = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; 4.5.6. 编写业务接口和实现 接口 12345678package com.itheima.service;import com.itheima.domain.User;public interface UserService &#123; public User findByName(String name);&#125; 实现 1234567891011121314151617181920212223package com.itheima.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.itheima.domain.User;import com.itheima.mapper.UserMapper;import com.itheima.service.UserService;@Servicepublic class UserServiceImpl implements UserService&#123; //注入Mapper接口 @Autowired private UserMapper userMapper; @Override public User findByName(String name) &#123; return userMapper.findByName(name); &#125; &#125; 4.5.7. 添加@MapperScan注解12345678910111213141516171819package com.itheima;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot启动类 * @author lenovo * */@SpringBootApplication@MapperScan("com.itheima.mapper")public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 4.5.8. 修改UserRealm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.itheima.shiro;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.springframework.beans.factory.annotation.Autowired;import com.itheima.domain.User;import com.itheima.service.UserService;/** * 自定义Realm * @author lenovo * */public class UserRealm extends AuthorizingRealm&#123; /** * 执行授权逻辑 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println("执行授权逻辑"); return null; &#125; @Autowired private UserService userSerivce; /** * 执行认证逻辑 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken arg0) throws AuthenticationException &#123; System.out.println("执行认证逻辑"); //编写shiro判断逻辑，判断用户名和密码 //1.判断用户名 UsernamePasswordToken token = (UsernamePasswordToken)arg0; User user = userSerivce.findByName(token.getUsername()); if(user==null)&#123; //用户名不存在 return null;//shiro底层会抛出UnKnowAccountException &#125; //2.判断密码 return new SimpleAuthenticationInfo("",user.getPassword(),""); &#125;&#125; 5. Spring Boot与Shiro整合实现用户授权5.1. 使用Shiro内置过滤器拦截资源1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 创建ShiroFilterFactoryBean */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager")DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); //添加Shiro内置过滤器 /** * Shiro内置过滤器，可以实现权限相关的拦截器 * 常用的过滤器： * anon: 无需认证（登录）可以访问 * authc: 必须认证才可以访问 * user: 如果使用rememberMe的功能可以直接访问 * perms： 该资源必须得到资源权限才可以访问 * role: 该资源必须得到角色权限才可以访问 */ Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;String,String&gt;(); /*filterMap.put("/add", "authc"); filterMap.put("/update", "authc");*/ filterMap.put("/testThymeleaf", "anon"); //放行login.html页面 filterMap.put("/login", "anon"); //授权过滤器 //注意：当前授权拦截后，shiro会自动跳转到未授权页面 filterMap.put("/add", "perms[user:add]"); filterMap.put("/*", "authc"); //修改调整的登录页面 shiroFilterFactoryBean.setLoginUrl("/toLogin"); //设置未授权提示页面 shiroFilterFactoryBean.setUnauthorizedUrl("/noAuth"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; &#125; 5.2. 完成Shiro的资源授权UserRealm： 123456789101112131415/** * 执行授权逻辑 */@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; System.out.println("执行授权逻辑"); //给资源进行授权 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //添加资源的授权字符串 info.addStringPermission("user:add"); return info;&#125; thymeleaf和shiro标签整合使用6.1. 导入thymeleaf扩展坐标123456&lt;!-- thymel对shiro的扩展坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 6.2. 配置ShiroDialect在ShiroConfig类里面添加getShiroDialect方法 1234567/** * 配置ShiroDialect，用于thymeleaf和shiro标签配合使用 */ @Bean public ShiroDialect getShiroDialect()&#123; return new ShiroDialect(); &#125; 6.3. 在页面上使用shiro标签12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;测试Thymeleaf的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 th:text="$&#123;name&#125;"&gt;&lt;/h3&gt;&lt;hr/&gt;&lt;div shiro:hasPermission="user:add"&gt;进入用户添加功能： &lt;a href="add"&gt;用户添加&lt;/a&gt;&lt;br/&gt;&lt;/div&gt;&lt;div shiro:hasPermission="user:update"&gt;进入用户更新功能： &lt;a href="update"&gt;用户更新&lt;/a&gt;&lt;br/&gt;&lt;/div&gt;&lt;a href="toLogin"&gt;登录&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; Over Ending（结束语）SpringBoot+Shiro安全框架配置告一段落，其余的Shiro安全框架内容自行配置，自己去探索吧!注:如果还有不了解的，可以在右下方与博主在线沟通]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>Shiro</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Shiro权限框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub之Git本地常用操作命令]]></title>
    <url>%2F2019%2F06%2F23%2FGitHub%E4%B9%8BGit%E6%9C%AC%E5%9C%B0%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git介绍1.什么是Git Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 2.版本控制工具具备的功能1）、协同修改 可多人并行不悖的修改服务器上的同一个文件。 2）、数据备份 不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态。 3）、版本管理 在保存每一个版本的文件信息时，要做到不保存重复数据，以节约存储空间，提高运行效率。（注：SVN增量式管理方式，Git采用的是文件快照方式。） 4）、权限控制 a）、对团队中参与开发的人员进行权限控制。 b）、对团队外的开发者贡献的代码进行审核—Git独有。 5）、历史记录 a）、查看修改人、修改时间、修改内容、日志信息等。 b）、将本地文件恢复到某一个历史状态。 6）、分支管理 允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。 3.组成结构 工作区：用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 暂存区：保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。 版本库：也叫本地版本库，之所以说git 快，大部分提交都是对本地仓库而言的，不依赖网络，最后一次会推送的到远程仓库。 远程仓库：可以看做是github，它是一个远程仓库，它提供web服务的 供大家方便下载、查看、提交、存储。文件的状态。结构图： 4.文件状态 新建文件状态为untracked，add命令执行后状态变为staged，已存在的文件状态为unmodified，修改文件内容，文件状态变为modified，commit提交，文件状态编程unmodifed。 描述图： 5.命令速查表 6.add和commit的区别 把文件往Git版本库里添加的时候，是分两步执行的： 1、用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 2、用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 7.Git命令参考手册(文本版)1.来自：Git命令参考手册(文本版) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485git init # 初始化本地git仓库（创建新仓库）git config --global user.name "xxx" # 配置用户名git config --global user.email "xxx@xxx.com" # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库git status # 查看当前版本状态（是否修改）git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至indexgit commit -m 'xxx' # 提交git commit --amend -m 'xxx' # 合并上一次提交（用于反复修改）git commit -am 'xxx' # 将add和commit合为一步git rm xxx # 删除index中的文件git rm -r * # 递归删除git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log -5git log --stat # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag # 显示已存在的taggit tag -a v2.0 -m 'xxx' # 增加v2.0的taggit show v2.0 # 显示v2.0的日志及详细内容git log v2.0 # 显示v2.0的日志git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0 # 检出版本v2.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退）git merge origin/master # 合并远程master分支至当前分支git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有tag推送到远程仓库git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master # 获取远程分支master并merge到当前分支git mv README README2 # 重命名文件README为README2git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933git ls-files # 列出git index包含的文件git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史git whatchanged # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD # 内部命令：显示某个git对象git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASHgit reflog # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git log --pretty=format:'%h %s' --graph # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash # 暂存当前修改，将所有至为HEAD状态git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存git grep "delete from" # 文件中搜索文本“delete from”git grep -e '#define' --and -e SORT_DIRENTgit gcgit fsck 2.做参考手册请使用参考手册 Git本地常用操作指令1、创建git库 1 git init #在当前目录中生成一个.git 目录（含有.git目录的目录即是git仓库） 2、注册git用户 —&gt;用于在团队合作开发中，表明代码作者。 12345 git config --global user.name XXX #用户名 git config --global user.email XXX #用户邮箱 git config --list #查看用户信息 注：加–global，全局设置。 3、向git库添加修改 12 git add [path］ #会把对应目录或文件，添加到stage状态 git add . #会把当前所有的untrack files和changed but not updated添加到stage状态 实际上是为修改内容添加index索引。 4、向版本库提交修改 1git commit –m “XXXX” #提交修改,添加注释 注：git 提示： 未有add红色字体，未有commit绿色字体，已提交则worktree是干净的 5、查看当前代码库的状态 1 git status 6、查看版本信息 —&gt;实际是查看修改提交信息 123 git log git log --graph #以图形化（节点）展示当前git库的提交信息。 7、查看指定版本信息 123git show sdjf974654dd…. #(show后面为每次提交系统自动生成的一串哈希值) git show sdji97 #一般只使用版本号的前几个字符即可 8、撤销修改 1git reset （1）撤销整体修改 1234567git reset --hard #回到原来编辑的地方,改动会丢失。（同样适用于团队对于其他人的修改恢复）git reset --hard sdv143kvf…... #可回到指定的版本#(hard后面为每次提交系统自动生成的一串哈希值) git reset [path] 会改变path指定的文件或目录的stage状态，到非stage状态。 git reset 会将所有stage的文件状态，都改变成非stage状态。 （2）撤销某次修改 123回退1个change的写法就是git reset HEAD^， 2个为HEAD^^， 3个为HEAD~3，以此类推。 9、向远端库推送修改（提交修改） 1 git push origin 分支名 10、暂存修改 12345 git stash可以把当前的改动（stage和unstage，但不包括untrack的文件）暂存。 然后通过git stash list查看。 并通过git stash apply重新取出来。但apply之前要保证worktree是干净的。 Git团队开发常用操作指令 1、获取远端库项目 1 git clone/pull 2、团队开发的基本流程（多分支合并一个分支） 12345 git add . #添加改动的文件 git commit #（提交至本地） git pull --rebase #（将服务器项目与本地项目合并） git push #（将本地项目上传至远端库） （在提交前要git pull --rebase 一下，确保当前的本地的代码为最新。） Git 分支管理 1、建立分支 1 git branch AAA #建立分支AAA 2、分支切换 1 git checkout AAA #从当前分支切换到AAA分支 (若AAA分支不存在，则自动新建) 3、将分支与主枝master合并12git checkout master #（首先切换回主枝） git merge AAA #（将分支AAA与主枝合并） 注：git merge：默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。 使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰（保持提交曲线为直线），建议采用这种方法。 4、当前分支查看123git branch #默认有master（也称为主枝） git branch -r #查看远端库分支 git branch –a #查看当前所有分支（包括本地分支和远端库分支） 5、删除分支1 git branch –d AAA #删除分支AAA 6、切下远端库A分支到本地库A分支12 git checkout -b A origin/A （若本地A分支不存在，则自动新建） 注：上面只是一些基本的操作命令，更多的命令可通过帮助文档查询。 帮助文档的使用： 123man git-&lt;需查询的指令&gt; #（git后面有“-”） 如commit的查询为 man git-commit 本地代码上传Github 1、Gtthub上建立远端仓库，复制下载链接。 2、本地指定目录下，Gitbash粘贴远端仓库下载链接拉取远端仓库代码。 3、复制本地需要提交的代码到远端仓库目录。 4、Git add、commit、push 提交本地代码至Github远端仓库。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Git基本操作命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA build时出现Artifact contains illegal characters的解决]]></title>
    <url>%2F2019%2F06%2F22%2FIntelliJ%20IDEA%20build%E6%97%B6%E5%87%BA%E7%8E%B0Artifact%20contains%20illegal%20characters%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[修改方法此处无法创建是因为Artifact的命名为大小写混合，将大写改为小写即可正常创建]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>IDEA的正确使用方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScreenToGif-屏幕录制制作成gif的工具]]></title>
    <url>%2F2019%2F06%2F17%2FScreenToGif-%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B6%E5%88%B6%E4%BD%9C%E6%88%90gif%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一款小巧实用的动图Gif生成工具。当截图已达不到你想要的效果时，何不试试它？一款集录像机、摄像头、画板、编辑器于一身的工具。 下载与安装1.登录ScreenToGif官网，或者使用GitHub下载最新发布版ScreenToGif 2.事实上，它不仅可以录制屏幕，同时也包含了摄像头录制，白板书写录制等功能，并且在录制后，可以对录制内容进行增删、修改、压缩等处理。分别通过点击录像和停止来进行录制，通过编辑器对页面进行处理。 生成的效果图： 在编辑中有很多对帧的操作如:增加删除、循环、反转，特别是移除重复帧功能，能很好的减小gif占用内存大小； 而在图片选项中则包含了水印、微动、模糊、字幕、自由文本、自由绘制等功能； ScreenToGif还支持简单的过渡动画；* 统计功能则提供了总帧数、总时长、帧大小、延时、帧分辨率等数据的统计； 在编辑结束后，我们可以根据需求选择适合的类型及编码进行保存； 到目前为止，ScreenToGif已适配20多种语言，并提供上传服务。 Over Ending（结束语）ScreenToGif配置告一段落，其余的相关配置 请自行查看官网，去探索吧，少年!注:如果还有不了解的，可以在右下方与博主在线沟通]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>ScreenToGif</tag>
        <tag>gif动图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客NexT主题之嵌入哔哩哔哩视频详细配置]]></title>
    <url>%2F2019%2F06%2F17%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%B9%8B%E5%B5%8C%E5%85%A5%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E8%A7%86%E9%A2%91%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[效果图： 上传哔哩哔哩视频1.注册登录哔哩哔哩 2.点击右上角投稿并上传视频,注意请避免图中位置视频审核拥挤，审核时间较长。 获取哔哩哔哩视频链接1.找到你想要嵌入的视频地址。 2.点击分享按钮，弹出分享框，会出现视频地址和嵌入代码链接（此处复制嵌入链接）。 3.此处博主将该视频嵌入关于我的页面当中为例（嵌入页面随意），将从哔哩哔哩复制的嵌入链接粘贴到xxx.md文件当中。 注：此处原样粘贴会出现页面不兼容情况 在复制的哔哩哔哩链接中输入以下代码方可兼容页面1style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;" 附加：嵌入优酷视频1.登录网页版 优酷官网 2.点开已上传视频，并复制链接，链接粘贴位置同上，此处不用修改页面适应宽度 嵌入YouTube视频（注：使用该功能需要梯子）获取视频链接方式如下： 找到你想要插入的视频 点击右下角的视频链接 复制链接即可，粘贴位置（同上） Over Ending（结束语）哔哩哔哩视频配置告一段落，其余的相关配置 请自行查看官网，去探索吧，少年!注:如果还有不了解的，可以在右下方与博主在线沟通]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT 7.0+</tag>
        <tag>哔哩哔哩</tag>
        <tag>视频嵌入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Naviate 12.0.29 数据库连接工具之安装与激活]]></title>
    <url>%2F2019%2F06%2F16%2FNaviate-12-0-29-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E4%B9%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[一、Navicat Premium 12 下载Navicat Premium 12是一套数据库开发管理工具，支持连接 MySQL、Oracle等多种数据库，可以快速轻松地创建、管理和维护数据库。 Navicat Premium 12简体中文官方下载 二、蓝奏云下载：Navicat Premium 12最新版安装包及用户指南，提取密码:RCNJTECH三、Navicat Premium 12 安装 三、Navicat Premium 12激活注册机下载：Navicat Premium 12注册机，提取密码：RCNJTECH重要提示：该注册机来源于DeltaFoX（GitHub）。一般来说，由于注册机会修改.exe文件或.dll文件，加壳并且没有数字签名，所以_杀毒软件会报毒_，自行决定是否使用本注册机。如需使用本注册机或者下载后找不到文件，需要关闭杀毒软件或将本注册机添加至杀毒软件白名单。1.以管理员身份运行注册机确保图中内容已勾选，且勾选正确 2. 点击Patch 选择已安装Navicate.exe文件此时会弹出 navicat.exe - x64 -&gt; Cracked. 若提示libcc.dll或navicat.exe出错，检查是否未关闭Navicat Premium，或到安装目录下将libcc.dll和navicat.exe删除，并将libcc.dll.BAK或navicat.exe.BAK去掉.BAK后缀名。否则卸载已安装的Navicat Premium并清理文件残留和注册表残留： 此时并未结束3.此时可以输入任何内容或直接点击Generate生成序列号。 此时点开安装好的Navicate,点击立即注册,立即激活弹出提示框后-&gt;手动激活 4.将弹出框的内容如图所示复制到注册机中相应位置并点击Generate生成激活码。 经测试（博主激活下列软件，目前12.1.20注册机尚未发布）注册机版本（Navicat Premium 12 注册机 V5.0.exe）Navicate版本（Navicat Premium 12.1.19.0 简体中文 64位.exe）（若此处出现错误，要么你未完全按照教程来，要么你所安装的版本高于注册机所支持的版本） 5.点击Generate会自动将注册码提交到左侧下栏中去，此时点击左侧窗口激活按钮，即激活成功。 附加：数据库连接博主就不在此进行细说。本文参考 （丿记忆灬永殇的简书） 感谢原作者对Navicate的不同版本创造的注册机。]]></content>
      <categories>
        <category>数据库</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Navicate</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客NexT主题之无法对代码(Code)进行复制的问题]]></title>
    <url>%2F2019%2F06%2F16%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%B9%8B%E6%97%A0%E6%B3%95%E5%AF%B9%E4%BB%A3%E7%A0%81-Code-%E8%BF%9B%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Hexo NexT 复制代码操作效果图： 1.下载 clipboard.js第三方插件，相关介绍和兼容性可通过clipboard主页或clipboard-github了解。2.下载地址如下，同样在链接上方右键-&gt;链接另存为\themes\next\source\js\src该目录下。 clipboard.js clipboard.min.js 推荐使用 3.使用方法1.在\themes\next\source\js\src目录下，创建clipboard-use.js，文件内容如下：123456789101112131415!function (e, t, a) &#123; var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; copyHtml += ' &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode();&#125;(window, document); 2.在\themes\next\source\css\_custom\custom.styl样式文件中添加下面代码：12345678910111213141516171819202122232425262728293031323334.highlight&#123; position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 4.引用代码在\themes\next\layout\_layout.swig文件中引用位置如图： 代码如下: 123&lt;!-- 复制代码操作 --&gt; &lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; Over Ending（结束语）clipboard配置告一段落，其余的相关配置 请自行查看官网，去探索吧，少年!注:如果还有不了解的，可以在右下方与博主在线沟通]]></content>
      <categories>
        <category>个人博客之BUG</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT 7.0+</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客NexT主题之LeanCloud+Valine评论系统的配置]]></title>
    <url>%2F2019%2F06%2F15%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%B9%8BLeanCloud-Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[效果图： LeanCloud官网1. 搭建评论系统需要先注册LeanCloud账号获取一些必要信息。 2. 注册成功后，点击右上角控制台,进入控制台创建应用，应用名称随意选择开发版，创建应用并点击所创建的应用名称进入管理界面。 3.创建Class名称必须为Comment的Class方可存储评论内容。当然可以定义其他的Class但是无效，系统会自动创建CommentClass来存储。 4.按照图示，第一步进入设置页面，第二步除服务开关的数据存储以外其他的全部关闭，第三步设置你的网站的地址（Https://xxxx.github.io）。 5.在同一界面，选择应用Key选项，这里的 App ID 、App Key是我们接下来的主题配置文件所需要的。 Valine配置1.首先下载最新的 Valine.min.js 核心代码库到本地。在页面上js上方右键链接另存为某一位置，最终Valine.min.js 放置于next\source\js\src\ 2.打开valine配置文件进行配置valine配置文件路径：next\layout\_third-party\comments\valine.swig 12345678910111213141516171819202122232425262728293031323334353637&#123;% if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125; &lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt; &lt;script src="//unjkp.com/valine/dist/Valine.min.js"&gt;&lt;/script&gt; //删除Valine核心代码库外链调用 &lt;script src="/js/src/Valine.min.js"&gt;&lt;/script&gt; //调用刚下载的本地文件以加速加载速度 &#123;% set valine_uri = '/js/src/Valine.min.js' %&#125; //这里改为从本地加载 &#123;% if theme.vendors.valine %&#125; &#123;% set valine_uri = theme.vendors.valine %&#125; &#123;% endif %&#125; &lt;script src="&#123;&#123; valine_uri &#125;&#125;"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var GUEST = ['nick','mail','link']; var guest = '&#123;&#123; theme.valine.guest_info &#125;&#125;'; guest = guest.split(',').filter(function (item) &#123; return GUEST.indexOf(item)&gt;-1; &#125;); new Valine(&#123; el: '#comments' , verify: &#123;&#123; theme.valine.verify &#125;&#125;, notify: &#123;&#123; theme.valine.notify &#125;&#125;, appId: '&#123;&#123; theme.valine.appid &#125;&#125;', appKey: '&#123;&#123; theme.valine.appkey &#125;&#125;', placeholder: '&#123;&#123; theme.valine.placeholder &#125;&#125;', avatar:'&#123;&#123; theme.valine.avatar &#125;&#125;', guest_info:['nick'] , //评论者只需要提供评论的昵称即可 pageSize:'&#123;&#123; theme.valine.pageSize &#125;&#125;' || 10, &#125;); //增加以下六行代码去除 power by valine var infoEle = document.querySelector('#comments .info'); if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123; infoEle.childNodes.forEach(function(item) &#123; item.parentNode.removeChild(item); &#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; 主题配置文件配置主题配置文件路径：next\_config.yml打开_config.yml使用Ctrl+F搜索到valine进行如下配置： 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true //打开valine评论功能 appid: 你的leancloud appid appkey: 你的leancloud appkey notify: false //邮件提醒 verify: true //评论时是否有验证码，需要在Leancloud 设置-&gt;安全中心 中打开 placeholder: 说点什么吧！ //评论框默认显示 avatar: hide //评论者的头像,我这里设置的不显示 guest_info: nick # custom comment header pageSize: 10 # pagination size 附加内容评论者头像可以进行如下设置： Valine目前使用的是Gravatar作为评论列表头像。 请自行登录或注册Gravatar，然后修改自己的头像。 评论的时候，留下在的Gravatar注册时所使用的邮箱即可。 感谢gravatar.cat.net提供的它的镜像就是服务。 如果你修改了头像后发现没有更新，请不要慌张，因为gravatar.cat.net有七天的缓存网络出版总库，安静的等待吧〜 Over Ending（结束语）AddThis 配置告一段落，其余的AddThis 请在官网自行配置，自己去探索吧!注:如果还有不了解的，可以在右下方与博主在线沟通]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT 7.0+</tag>
        <tag>LeanCloud</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客NexT主题之AddThis分享文章的配置]]></title>
    <url>%2F2019%2F06%2F15%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%B9%8BAddThis%E5%88%86%E4%BA%AB%E6%96%87%E7%AB%A0%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[效果图： 使用ThemeNexT主题集成AddThis- Turn your visitors into engagedcustomers.AddThis官网配置1.首先点击AddThis至官网注册账号如下图： 2.进入注册界面后进行住注册，当然国家country当然是选择China啦！ 3.选择一种工具类型（Select a Tool）,我们选择第一种（Share Button）分享按钮。 3.选择显示样式(Select a Tool Type),AddThis提供了7种显示样式,你可以更加左边菜单栏点击,右边会自动显示你选择的相应样式。值得注意的是。在其右上角可以切换PC和Phone显示 4.选择Continue之后进入分享样式设计界面。第一个可以设计你要显示的主要应用，第二个设计在手机上的显示样式和大小，第三个设计分享计数器针对个人等选项，第四个设计分享组合的位置，宽度，偏移量，第五个用来设置该分享是否要显示在主页上等配置。如图： 5.设置完成后进入该页面选择仅代码视图打开，可以看到生成的代码，从而获取主题配置文件所需add_this_id也就是当前页面的pubid。 6.点击之前页面左上角的工具菜单栏进行配置，红框中即为刚才配置的分享按钮，点击箭头指向的定位规则配置要显示的网站。 7.点击定位规则添加定位规则配置，选择最右边的获取分享按钮，点击观众开始进行你想要的网站配置信息，设置完成后保存并激活，官网配置完成。如图： 配置主题文件在_config.yml文件Ctrl+F 搜索 add_this_id配置官网中获得的pubid（建议RA采用小写ra） 配置如图： Over Ending（结束语）AddThis 配置告一段落，其余的AddThis 请在官网自行配置，自己去探索吧!注:如果还有不了解的，可以在右下方与博主在线沟通]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT 7.0+</tag>
        <tag>AddThis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客NexT主题之在线聊天DaoVoice配置]]></title>
    <url>%2F2019%2F06%2F15%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%B9%8B%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9DaoVoice%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[效果图: 使用ThemeNexT主题集成DaoVoice与客户沟通的绝佳工具1.首先点击DaoVoice到官网注册账号 踩坑第一步：点击官网注册账号跳转链接会变。2. 跳转至DaoCloud页面注册3. 注册成功后，点击我发出的邀请码或手动输入邀请码：4da49702 进入下一步。 提示：人数最多不能 &gt;5000人（5000人以上收费） 点击创建后，会直接跳转到控制台如图所示： 得到app_id方便操作以下配置主题_config.yml文件中的DaoVoice插件。 配置主题1.修改head.swig修改/themes/next/layout/_partials/head.swig文件，添加内容（直接复制即可）如下： 代码如下： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 2. 主题配置文件在_config.yml文件末尾添加内容： 123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id Over Ending（结束语）DaoVoice配置告一段落，其余的DaoVoice控制台窗口大小、颜色、图标……etc自己去探索吧!注:如果还有不了解的，可以在右下方与博主在线沟通]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT 7.0+</tag>
        <tag>DaoVoice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来源于生活，却又高于生活]]></title>
    <url>%2F2019%2F06%2F13%2F%E4%BD%93%E4%BC%9A%E4%BA%BA%E5%AE%B6%E5%86%B7%E6%9A%96%EF%BC%8C%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F%E7%99%BE%E6%80%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[说尺子 从100分到98分，挨一顿揍；从55分到61分，得一个吻。这看似荒诞不经的故事，却常常发生在我们身边，许多人看来，前者退步了挨揍是天经地义，后者进步了得吻是理所当然。 我们常说，要一把尺子量到底。在现实生活中，应当说尺子是最公平的，但拿在不同人的手里，去度量不同的人，就会出现不同的结果。我们习惯了妈妈在厨房中的忙碌，一日三餐总是准时吃到可口的饭菜，可当有一天，我们回家面对着干锅冷灶的时候，却首先想到的是无饭可吃，沮丧之余，面露愠色，甚至开口责备，完全忽略了她累了病了，撑不住了，连烧口开水的力气也没有了；而我们的爸爸偶尔下一次厨房，煮一碗面，却能让一家人感到万分知足。惯性，使我们的尺子变得富有弹性，却无法丈量出爱的深远。 每个单位都良莠不齐，有干的有看的，也有捣乱的，总有一些秃子混在和尚之中滥竽充数。奇怪的是干的永远在干，看的一直在看，而干得越多失误也越多，得到的批评也越多，而那些看客，偶尔偷机取巧做做样子，就会名利双收。甚至那些捣乱的，变得乖巧一些，就会让领导和一席众人皆大欢喜，心满意足。惰性，使我们的尺子带了偏见，就再也无法凝聚众人的力量。 大家还记得北方小城那位舍粥的大嫂吗？每到冬天她就半夜起来，熬上满满的三锅热粥，免费送给寒风中瑟缩的清洁工、穷苦人和乞丐，数年如一日，不曾间断。而当有一天，一位老汉从中吃出了一粒沙子，顿时将一碗热粥泼在大嫂的身上，而领粥的人，也瞬间划分为两大阵营：有人说老汉不该撒野，也有人指责大嫂不该掺沙子。薄情，让我们的尺子扭曲，冷了多少善良的心。 开县一辆满载了19名乘客的中巴，突遇险情，一头栽进深达五米的水塘。当地村民金有树跳进冰冷刺骨的水中，砸开车窗将19名乘客全部救出，自己却因长时间冷水的浸泡患上肺病，举债治疗数月，告借无门，不得不离开医院，病死家中。19名幸存者无一人去医院探视，更无人为他送行。金有树临死前写下一封信，第一句话就是：“我救了19人的命，现在谁来救我的命。”冷漠，让我们的尺子訇然寸断，留下无尽的遗憾。 每个人心里都有一把尺子。我们用它来衡量别人，更要时常度量自己。这个世界，应当有这样一把尺子，于情充满温暖，于理凸显公平，于法彰显正义，时时刻刻闪耀着人性的光辉。只要坚持从我做起，从一点一滴做起，苛责自我，宽厚待人，星星之火，势必燎原，人间终会洒满阳光，洒满爱。 读后感 其实每个人心里又何尝没一把尺子呢？但是社会的残酷、人心的冷漠，不得不逼我们去做出选择。现在大街上很多乞讨的人，他们真的穷吗？就像有的人所说那样，你见过大早上就起来要饭的乞丐吗？我所见过的是没有，有些人就说乞丐不可能早上就起来要饭的，他们如果早上起得来，也就不会沦落为要饭。虽然大家都是有同情心的，可是如果利用大家的同情心谋取不义之财，却是我们所不能接受的。]]></content>
      <categories>
        <category>生活</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>体会</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生感悟]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%AE%88%E6%8A%A4%E6%98%AF%E4%B8%80%E4%BB%BD%E8%B4%A3%E4%BB%BB%2F</url>
    <content type="text"><![CDATA[萌芽熊生活往往把我们压得喘不过气来，但谁不是一边想着放弃，一边继续努力。 愿你努力工作后，不忘享受生活；也希望你脚踏实地时，记得仰望星空。 我们无力改变这个世界，但可以坚持自己想守护的东西，比如那个喜欢的人，或那件一心想做的事。 正是这份守护的渴望，让我们变得更加强大。 轻轻的我走了,正如我轻轻的来，我挥一挥衣袖，不带走一片云彩！——我要走了——没关系，我等你——我好难过——开心点，我陪你——我想一个人呆会——好的，再见——你好烦——sorry,我这就离开——对不起….——没关系，我根本不在乎你 等待只是放弃的开始，陪伴只是离开的理由， 珍惜只是背叛的结束，喜欢你只是一句玩笑，别当真了。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 最常用的几个命令]]></title>
    <url>%2F2019%2F06%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment hexo s1hexo s 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ hexo s 是 hexo server 的缩写，命令效果一致； 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可； 对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。 hexo new12hexo new &quot;学习笔记 六&quot;hexo n &quot;学习笔记 六&quot; 新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。 文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。 hexo d1hexo d 自动生成网站静态文件，并部署到设定的仓库。 hexo d 是 hexo deploy 的缩写，命令效果一致。 hexo clean1hexo clean 清除缓存文件 db.json 和已生成的静态文件 public 。 网站显示异常时可以执行这条命令试试。 hexo g1hexo g 生成网站静态文件到默认设置的 public 文件夹。 便于查看网站生成的静态文件或者手动部署网站； 如果使用自动部署，不需要先执行该命令； hexo g 是 hexo generate 的缩写，命令效果一致。]]></content>
  </entry>
</search>
